using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using XamlAnimatedGif;

namespace CosmicKoiPond
{
    /// <summary>
    /// SpawningCreatures bring life to the app. They move around the koi pond.
    /// 
    /// A creature has 3 states:
    /// 1. Spawning
    /// 2. Transitioning
    /// 3. Cycling
    /// 
    /// Each of these states has a unique animation.
    /// Movement starts after the spawning sate is finished.
    /// </summary>
    public class SpawningCreature
    {
        // Sound that gets played when this creature spawns
        public readonly Uri SoundUri;

        public readonly float Scale;
        public readonly CreatureType Type;
        public readonly TimeSpan Duration; // Duration for the movement animation
        public readonly VideoOutput VideoWindow;

        // Image URIs
        public readonly Uri SpawnUri;
        public readonly Uri TransUri;
        public readonly Uri CycleUri;

        // Left or right, for fishes only because they are generated by waving left/right
        public readonly Direction Direction;

        // Images that store the fish animations
        public Image SpawnImage;
        public Image TransImage;
        public Image CycleImage;

        // Destination point
        public Point Offset;

        // Storyboard handling animation
        private readonly Storyboard _storyboard = new Storyboard();

        // MediaElement that playing sound
        private MediaElement _mediaElement;

        public SpawningCreature(float scale, 
                                CreatureType type, 
                                Uri spawnUri, 
                                Uri cycleUri, 
                                Uri soundUri, 
                                Direction direction, 
                                VideoOutput videoWindow,
                                Uri transUri = null)
        {
            // Do a bit of variation on the scale (+-30%)
            // i want to have values from 0.7 to 1.3
            Random random = new Random();
            float scalingFactor = random.Next(70, 130);
            scalingFactor /= 100; // now it's 0.7 to 1.29 (good enough)
            Scale = scale * scalingFactor;

            Type = type;

            SpawnUri = spawnUri;

            // If no transition uri is specified, play the cycle uri once (spawn 1x -> cycle 1x -> cycle forever)
            TransUri = transUri ?? cycleUri;
            
            CycleUri = cycleUri;

            SoundUri = soundUri;
            Direction = direction;

            // Sets the duration to 10-20 seconds
            Duration = new TimeSpan(0, 0, new Random().Next(10, 21));

            VideoWindow = videoWindow;

            Spawn();
        }

        public void Spawn()
        {
            //ANIMATION
            BitmapImage refImage = new BitmapImage(SpawnUri); // for reading image size

            CycleImage = new Image();
            TransImage = new Image();
            SpawnImage = new Image();

            CycleImage.Width = refImage.Width * Scale;
            CycleImage.Height = refImage.Height * Scale;
            TransImage.Width = refImage.Width * Scale;
            TransImage.Height = refImage.Height * Scale;

            SpawnImage.Width = refImage.Width * Scale;
            SpawnImage.Height = refImage.Height * Scale;

            AnimationBehavior.SetAutoStart(CycleImage, false);
            AnimationBehavior.SetSourceUri(CycleImage, CycleUri);
            AnimationBehavior.SetRepeatBehavior(CycleImage, RepeatBehavior.Forever);

            AnimationBehavior.SetAutoStart(TransImage, false);
            AnimationBehavior.SetSourceUri(TransImage, TransUri);
            AnimationBehavior.SetRepeatBehavior(TransImage, new RepeatBehavior(1));
            AnimationBehavior.AddLoadedHandler(TransImage, (sender, args) => AnimationBehavior.GetAnimator(sender as Image).AnimationCompleted += TransitionFinished);

            AnimationBehavior.SetAutoStart(SpawnImage, true);
            AnimationBehavior.SetSourceUri(SpawnImage, SpawnUri);
            AnimationBehavior.SetRepeatBehavior(SpawnImage, new RepeatBehavior(1));

            AnimationBehavior.AddLoadedHandler(SpawnImage, (sender, args) => AnimationBehavior.GetAnimator(sender as Image).AnimationCompleted += BeginTransition);

            // Calculate where the creature is spawning (300/200 border padding)
            Random random = new Random();

            // 20% padding on each side
            int leftOffset = random.Next((int) (VideoWindow.ActualWidth/5),(int) (VideoWindow.ActualWidth - SpawnImage.ActualWidth - (int) (VideoWindow.ActualWidth/5)));
            int topOffset = random.Next((int) (VideoWindow.ActualHeight/5),(int) (VideoWindow.ActualHeight - SpawnImage.ActualHeight - (int) (VideoWindow.ActualHeight/5)));

            Canvas.SetTop(SpawnImage, topOffset);
            Canvas.SetTop(CycleImage, topOffset);

            Canvas.SetTop(TransImage, topOffset);
            Canvas.SetLeft(TransImage, leftOffset);
            
            Canvas.SetLeft(SpawnImage, leftOffset);
            Canvas.SetLeft(CycleImage, leftOffset);

            /* 
             * 0 top
             * 1 right
             * 2 bottom
             * 3 left
             */

            int exitSide = random.Next(4);

            if (Direction == Direction.Left)
            {
                exitSide = 3;
            } else if (Direction == Direction.Right)
            {
                exitSide = 1;
            }

            double xOffset = 0;
            double yOffset = 0;

            switch (exitSide)
            {
                case 0:
                    xOffset = random.Next((int)-VideoWindow.ActualWidth, (int)VideoWindow.ActualWidth);
                    yOffset = -(VideoWindow.ActualHeight + CycleImage.ActualHeight + 100);
                    break;
                case 1:
                    xOffset = VideoWindow.ActualWidth + 100;
                    yOffset = random.Next((int)-VideoWindow.ActualHeight, (int)VideoWindow.ActualHeight);
                    break;
                case 2:
                    xOffset = random.Next((int)-VideoWindow.ActualWidth, (int)VideoWindow.ActualWidth);
                    yOffset = VideoWindow.ActualHeight + 100;
                    break;
                case 3:
                    xOffset = -(VideoWindow.ActualWidth + CycleImage.ActualWidth + 100);
                    yOffset = random.Next((int)-VideoWindow.ActualHeight, (int)VideoWindow.ActualHeight);
                    break;
            }

            Offset = new Point(xOffset, yOffset);


            // rotate the image in the target direction
            // http://stackoverflow.com/a/17530420

            double angle;
            double x = xOffset;
            double y = yOffset;

            if (x < 0)
            {
                angle = 270 - (Math.Atan(y / -x) * 180 / Math.PI);
            }
            else
            {
                angle = 90 + (Math.Atan(y / x) * 180 / Math.PI);
            }

            RotateTransform rotateTransform = new RotateTransform(angle);
            CycleImage.RenderTransform = rotateTransform;
            TransImage.RenderTransform = rotateTransform;
            SpawnImage.RenderTransform = rotateTransform;

            // Add the two/three images to the Canvas
            VideoWindow.MyCanvas.Children.Add(SpawnImage);

            TransImage.Opacity = 0;
            VideoWindow.MyCanvas.Children.Add(TransImage);
            
            CycleImage.Opacity = 0;
            VideoWindow.MyCanvas.Children.Add(CycleImage);

            // SOUND
            _mediaElement = new MediaElement
            {
                UnloadedBehavior = MediaState.Close,
                Source = SoundUri
            };


            VideoWindow.Body.Children.Add(_mediaElement);

            // does this work?
            _mediaElement.MediaEnded += MediaElementOnMediaEnded;
        }

        /// <summary>
        /// Removes the sound element for a spawningCreature after it finishes playing
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="routedEventArgs"></param>
        private void MediaElementOnMediaEnded(object sender, RoutedEventArgs routedEventArgs)
        {
            VideoWindow.Body.Children.Remove((MediaElement) sender);
        }

        private void BeginTransition(object sender, EventArgs e)
        {
            AnimationBehavior.GetAnimator(TransImage).Play();
            TransImage.Opacity = 1;
            VideoWindow.MyCanvas.Children.Remove(SpawnImage);
            Move();
        }

        private void TransitionFinished(object sender, EventArgs e)
        {
            AnimationBehavior.GetAnimator(CycleImage).Play();
            CycleImage.Opacity = 1;
            VideoWindow.MyCanvas.Children.Remove(TransImage);
        }

        private void Move()
        {
            var xAnimationCycle = new DoubleAnimation
            {
                To = Canvas.GetLeft(CycleImage) + Offset.X,
                Duration = Duration
            };

            var yAnimationCycle = new DoubleAnimation
            {
                To = Canvas.GetTop(CycleImage) + Offset.Y,
                Duration = Duration
            };

            var xAnimationTrans = new DoubleAnimation
            {
                To = Canvas.GetLeft(TransImage) + Offset.X,
                Duration = Duration
            };

            var yAnimationTrans = new DoubleAnimation
            {
                To = Canvas.GetTop(CycleImage) + Offset.Y,
                Duration = Duration
            };

            Storyboard.SetTarget(xAnimationTrans, TransImage);
            Storyboard.SetTargetProperty(xAnimationTrans, new PropertyPath("(Canvas.Left)", null));
            Storyboard.SetTarget(yAnimationTrans, TransImage);
            Storyboard.SetTargetProperty(yAnimationTrans, new PropertyPath("(Canvas.Top)", null));

            _storyboard.Children.Add(xAnimationTrans);
            _storyboard.Children.Add(yAnimationTrans);

            Storyboard.SetTarget(xAnimationCycle, CycleImage);
            Storyboard.SetTargetProperty(xAnimationCycle, new PropertyPath("(Canvas.Left)", null));
            Storyboard.SetTarget(yAnimationCycle, CycleImage);
            Storyboard.SetTargetProperty(yAnimationCycle, new PropertyPath("(Canvas.Top)", null));

            _storyboard.Children.Add(xAnimationCycle);
            _storyboard.Children.Add(yAnimationCycle);
            _storyboard.Begin();
        }

        public void CleanUp()
        {
            AnimationBehavior.GetAnimator(CycleImage).Pause();  // pause the animation of the cycle image
            _storyboard.Children.Clear(); // remove all animations from storyboard (movement + rotation)
            _storyboard.Stop(); // stop the storyboard
        }
    }
}
